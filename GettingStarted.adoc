# Outline

* Project setup
** Dependencies
** Dev cljs build w/devtools & figwheel

* Basic Components (defui)
** React render method
*** Props
** DOM elements (js maps)
** Composing
*** Show how the tree of data is established from root

* Feeding the Data Tree
** Data passing through root
** Why Can't Components just "grab" their data (sideband)?
*** They could, but systems like re-frame do so and then end up with complications like event handler middleware, coeffect accretion,
 and signal graphs.
** Setting up the Data Feed
*** Establishing a query for the data. Props and joins.
*** Establishing initial state for a component (InitialAppState)
** Passing computed data from the parent (callbacks, etc.)
*** UI Refresh can optimize away the render of the parent and feed the component directly.
    Anything the parent had sent in needs to be annotated so it can be re-sent.

* Updating the Data Tree
** transact! runs a mutation that can modify the data tree
*** Only re-renders the subtree where it was run
*** Mutations that affect parent are usually written in the parent and triggered via callbacks
** Mutations (defmutation)
** Problems:
*** Mutations tied to location in tree
*** Breaks ability to relocate a UI component on demand

* Normalizing the Database
** Idents and the Effects
** How the query is used to figure out normalization
** Updated mutations: now not location dependent!
** Locality of reasoning restored!

* Setting up a Server
** Easy Server
** Starting the Server
** Server Refresh
** Serving your App

* Going Remote!
** Loading Data
*** Loading a specific entity and it's subgraph (by ident)
**** The server query processing
**** Note on normalization: it happens
*** Loading something that gets "added in" to an existing entity
**** Choosing a server query keyword (ensuring no conflict at root)
**** Targeting the result
**** The server query processing
*** Loading items into a table, then morph them into the UI
**** The server query processing
**** Post mutations
** Handling Mutations
